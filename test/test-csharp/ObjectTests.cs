using DamonAllison.CSharpTests.Objects;
using System;
using System.Collections.Generic;
using Xunit;

namespace DamonAllison.CSharpTests
{
    public class ObjectTests 
    {

        [Fact]
        public void ObjectInitializerTest()  
        {
            // C# 3.0 added object initializers. Object initializers
            // allow you to set field / property values on the object.
            // 
            // This is strictly syntactic sugar. The IL generated by 
            // object initializers is exactly the same as if you would manually
            // set properties following the creation of the object.
            Person p = new Person() 
            {
                FirstName = "Damon", 
                LastName = "Allison"
            };
            Assert.True(p.Id > 0);
            Assert.Equal(Person.NextId, p.Id + 1);
        }

        [Fact]
        public void CollectionInitializerTest() 
        {
            // C# 3.0 added collection initializers. 
            // Collection initializers allow you to add elements to the collection 
            // at instiantiation.
            IList<Person> family = new List<Person>() 
            {
                new Person() 
                {
                    FirstName = "Damon", 
                    LastName = "Allison"
                },
                new Person() 
                {
                    FirstName = "Kari", 
                    LastName = "Allison"
                } 
            };
            Assert.Equal(2, family.Count);
        }

        [Fact]
        public void ExtensionMethodTest()
        {
            string damon = "damon";
            Assert.Equal("Damon", damon.Capitalize());
        }

        /// <summary>
        /// Conversion operators (implicit or explicit) allow you to convert
        /// a type (A) to another type (B) where the two types are not part 
        /// of an inheritance hierarchy.
        /// </summary>
        [Fact]
        public void ConversionOperatorTest() 
        {
            Person p = new Person("Test", "User");
            string s = (string)p;
            Assert.Equal("Test User", s);
        }

        [Fact]
        public void InheritanceTest()
        {
            Employee e = new Employee("Damon", "Allison", "allidam");
            Assert.IsAssignableFrom<Employee>(e);
            Assert.IsAssignableFrom<Person>(e);
            Assert.IsAssignableFrom<IIdentity>(e);

            Person p = e;
            IIdentity i = p;
            Assert.Equal("Allison, Damon", e.Name);
            Assert.Equal("Allison, Damon", p.Name);
            Assert.Equal(p.Id, i.Id);

            // Note that we have three references to the same object. 
            Assert.True(Object.ReferenceEquals(e, p));
            Assert.True(Object.ReferenceEquals(p, i));

            // `is` determines if an object is of a given type. Generally, you want
            // to avoid having to downcast an object. You should be able to work with 
            // an object as it's declared in the current scope. If you need to downcast, 
            // consider changing the declaration of the function to require the specific
            // type you are looking for.
            Assert.True(p is IIdentity);
            Assert.True(p is IdentityBase);
            Assert.NotNull(p as Employee);

            // `as` goes a step beyond `is`. If the object is of a given type, it will
            // convert the type and return a reference to the object as the target type
            // or `null` if the cast is not valid.
            //  
            // C#'s' type checker is smart enough to know that p (Person) cannot be converted
            // to a string. Therefore, we cast to `object` to fool the type checker.      
            Assert.Null((object)p as string);  
        }

        /// <summary>
        /// Person's abstract base class, <see cref="IdentityBase"/> defines
        /// a static member "NextId". When any new IdentityBase object is created,
        /// it must have a new, unique Id. This test verifies that identities are 
        /// handled correctly by the base.  
        /// </summary>
        [Fact]
        public void AbstractBaseTest()
        {
            // Employee and person both derive from AbstractBase, therefore 
            // they both will contain unique identifiers
            Person one = new Person("Damon", "Allison");
            Employee two = new Employee("Damon", "Allison", "allidam");
            Assert.True(one.Id > 0);
            Assert.True(two.Id == one.Id + 1);
            Assert.True(Person.NextId == two.Id + 1);

        }

        /// <summary>
        /// Explicit interface implementation requires the caller cast an
        /// object to the interface reference before calling a member.
        /// 
        /// In our object hierarchy, ILoggable is explicitly implemented
        /// by IdentityBase. Therefore, you must cast all objects to ILoggable
        /// to log them. Any member explicitly implemented is not added to the 
        /// type's declaration space.
        /// 
        /// Explicit interface implementation is preferred when the interface's 
        /// members are not essential to the object.
        ///   
        /// Favor explicit implementations when possible to reduce the type's 
        /// footprint.
        /// </summary>
        [Fact]
        public void ExplicitInterfaceImplementation()
        {
            Person p = new Person();

            
            p.LogToDB();

            // Note that LogToDB is an extension method in ILogableExtensions. 
            // Extension methods work with interfaces in the same way they work
            // with concrete types.
            ((ILogable)p).Log();
        }
    }
}